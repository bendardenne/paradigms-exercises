% Oplossingen Oefeningensessie 2: Lists and Difference-lists% ==============================% Vraag 1% -------%	.(a,[])%	.(a,.(b,.(c,[])))%	.(a,L)%	.(a,.(b,.(c,L)))% Vraag 2% -------%	[a|[]]%	[a|[b|[c|[]]]]%	[a|L]%	[a|[b|[c|L]]]% Vraag 3% -------%	[a]%	[a,b,c]%	[a|L]%	[a,b,c|L]% Vraag 4% -------member(X,[X|_]).member(X,[_|T]) :- member(X,T).my_append([],L,L).my_append([H|T1],L,[H|T2]) :- my_append(T1,L,T2).last([X],X).last([H|T],X) :- last(T,X).shiftleft([],[]).shiftleft([H|T],L) :- my_append(T,[H],L).shiftright(L1,L2) :- shiftleft(L2,L1).my_delete(X,[],[]).my_delete(X,[X|T],L) :- my_delete(X,T,L).my_delete(X,[H|T1],[H|T2]) :- not(X=H), my_delete(X,T1,T2).% Vraag 5% -------%	a) Reverse%	b) L=[3,2,1]%	c) L=[3,2,1]% Vraag 6% -------insert(X,L,[X|L]).insert(X,[Y|L],[Y|T]) :- insert(X,L,T).permutation([],[]).permutation([H,T],L) :- permutation(T,PT),insert(H,PT,L).% Vraag 7% -------% Deel (a)%	[1,2,3|X]-X% Deel (b)%	X-X% Deel (c)%	L-[]% Deel (d)%	X-L% Deel (e)%	Om twee expressies te unifieren kan je het predicaat = gebruiken.%	( Om te kijken of twee expressies niet unifieerbaar zijn gebruik je%     het predicaat \= )%	Het resultaat van de query%		[1,2,3,4]-Y = [1,2,3|A]-[4,5]%	is%		Y=[4,5]%	A=4% Vraag 8% -------% Deel (a) % Eerste poging:%	my_append_dl(A-B,C-D,E-F) :- my_append(A,C,E), my_append(B,D,F).% Deze poging maakt echter gebruik van gewone lijsten, en dat is niet wat% we willen. Het voorbeeld van difference-lists is immers precies dat je% hiermee programma's meestal veel korter en efficienter kan schrijven. Bvb:% Tweede poging:my_append_dl(Xs-Ys,Ys-Zs,Xs-Zs).% Deze is veel efficienter (constante tijd) en korter dan my_append (tijd% lineair met de lengte van de lijst)! % OPMERKING: je betaalt wel een prijs voor deze winst in efficientie! De% eerste versie werkt "altijd" terwijl de tweede versie alleen twee% difference-lists A-B en C-D kan appenden indien B en C unifieerbaar zijn.% (Als dat niet het geval is kan de regel immers niet afgevuurd worden.)% Voorbeeld:%		my_append_dl([a, b, c]-[c], [1, 2]-[], Ys)%   geeft resultaat%		Ys =  [a, b, c, 1, 2]-[c]%	voor de eerste versie, maar geeft geen resultaat voor de tweede versie.% Gelukkig is dit niet zo'n probleem, omdat we toch meestal zullen werken met% diiference-lists van de vorm X-L, waarbij L nog ongdefinieerd is, en dus% unifieerbaar is met om het even wat. % Deel (b) % 	Het resultaat van de query%		my_append_dl([a,b,c|Xs]-Xs,[1,2]-[],Ys)%	is%		Xs=[1,2]%		Ys=[a,b,c,1,2]-[]% Deel (c)% Het idee is het volgende. Begin metmy_reverse(Alist,Revlist) :- my_reverse_dl(Alist,Revlist-[]).% en gebruik het tweede stuk van Revlist-[] als accumulator die initieel% leeg is, maar waar beetje bij beetje de elementen die uit Alist gehaald% worden ingestopt worden.my_reverse_dl([H|T],Revlist-Acc) :- my_reverse_dl(T,Revlist-[H|Acc]).% Als de om te keren lijst uiteindelijk leeg is geraakt, betekent dat dat de% accumulator de omgekeerde lijst volledig bevat, en moeten we deze% accumulator dan nog unifieren met Revlist.my_reverse_dl([],RevList-RevList).% Vraag 9% -------% Deel (a)flatten([],[]).flatten(Atom,[Atom]) :- atomic(Atom), Atom\=[].flatten([Head|Tail],Flat) :- flatten(Head,FlatHead), flatten(Tail,FlatTail), append(FlatHead,FlatTail,Flat). % VOORBEELD:%	flatten([1, [[[[2]], [4, [5]]]], [3]], L)%	L =  [1, 2, 4, 5, 3]% Deel (b)% begin metflatten_b(Nested,Flat) :- flatten_dl(Nested,Flat-[]).% de rest is een rechtstreekse vertaling van de oplossing uit deel a naar% difference-lists. flatten_dl([],L-L).flatten_dl(Atom,[Atom|L]-L) :- atomic(Atom), Atom\=[].flatten_dl([Head|Tail],L1-L2) :- 	flatten_dl(Head,H1-H2), flatten_dl(Tail,T1-T2), 	append_dl(H1-H2,T1-T2,L1-L2).% De laatste regel kan je zelfs iets korter en efficienter schrijven door niet% append_dl op te roepen, maar dezelfde truuk toe te passen als in de% definitie van append_dl:%	flatten_dl([Head|Tail],A-C) :- %		flatten_dl(Head,A-B), flatten_dl(Tail,B-C). % VOORBEELD:%	flatten_b([1, [[[[2]], [4, [5]]]], [3]], L)%	L =  [1, 2, 4, 5, 3]% Deel (d)% Het enige verschil is dat je na het recursief oproepen van de procedure op de% head en de tail, de tail VOOR de head moet plakken!flatten_c(Nested,Flat) :- flatten_rev(Nested,Flat-[]).flatten_rev([],L-L).flatten_rev(Atom,[Atom|L]-L) :- atomic(Atom), Atom\=[].flatten_rev([Head|Tail],L1-L2) :-  flatten_rev(Head,H1-H2), flatten_rev(Tail,T1-T22),  append_dl(T1-T2,H1-H2,L1-L2). % Hetgeen weer iets korter en efficienter schrijven door de definitie van% append_dl onmiddellijk in te vullen:%	flatten_rev([Head|Tail],A-C) :- %		flatten_rev(Head,B-C), flatten_rev(Tail,A-B).