% Oplossingen Oefeningensessie 4: Cuts% ==============================% Vraag 1% -------% Deel (a) : f1(X,0) :- X<3.f1(X,2) :- 3=<X, X<6.f1(X,4) :- 6=<X.% f1(1, Y),2<Y  =>  No solutions found% Deel (b) :f2(X,0) :- X<3, !.f2(X,2) :- 3=<X, X<6, !.f2(X,4) :- 6=<X,!.% f2(1, Y),2<Y  =>  No solutions found% Deel (c) :f3(X,0) :- X<3, !.f3(X,2) :- X<6, !.f3(X,4).% f3 is echter niet volledig equivalent met f1 en f2, want% f1(1,2)  =>  No solutions found% f2(1,2)  =>  No solutions found% f3(1,2)  =>  Yes% Deel (d) :f4(X,Y) :- X<3, !, Y=0.f4(X,Y) :- X<6, !, Y=2.f4(X,4).% Deel (e) :% (a) gebruikt geen cuts% (b) gebruikt groene cuts% (c) en (d) gebruiken rode cuts% Vraag 2% -------% merge(List1,List2,Result) :- merge two sorted lists List1 and List2% (a) Zonder cuts.merge1([X|Xs],[Y|Ys],[X|M]) :- X<Y, merge1(Xs,[Y|Ys],M).merge1([X|Xs],[Y|Ys],[X,Y|M]) :- X=Y, merge1(Xs,Ys,M).merge1([X|Xs],[Y|Ys],[Y|M]) :- X>Y, merge1([X|Xs],Ys,M).merge1([],Ys,Ys).merge1(Xs,[],Xs).% (b) Met groene cuts.merge2([X|Xs],[Y|Ys],[X|M]) :- X<Y, !, merge2(Xs,[Y|Ys],M).merge2([X|Xs],[Y|Ys],[X,Y|M]) :- X=Y, !, merge2(Xs,Ys,M).merge2([X|Xs],[Y|Ys],[Y|M]) :- X>Y, !, merge2([X|Xs],Ys,M).merge2([],Ys,Ys) :- !.merge2(Xs,[],Xs) :- !.% (c) Trace van merge([1, 3, 5], [2, 3], Xs)% De trace voor merge1 is als volgt:%call  merge1([1, 3, 5], [2, 3], _1165)%UNIFY 1 [_1165=[1| _1691]]% call  1<2% call  merge1([3, 5], [2, 3], _1691)% UNIFY 1 [_1691=[3| _1913]]%  call  3<2% UNIFY 2 [_1691=[3, 2| _1916]]%  call  3=2% UNIFY 3 [_1691=[2| _1915]]%  call  3>2%  call  merge1([3, 5], [3], _1915)%  UNIFY 1 [_1915=[3| _2137]]%   call  3<3%  UNIFY 2 [_1915=[3, 3| _2140]]%   call  3=3%   call  merge1([5], [], _2140)%   UNIFY 5 [_2140=[5]]%  UNIFY 3 [_1915=[3| _2139]]%   call  3>3%UNIFY 2 [_1165=[1, 2| _1694]]% call  1=2%UNIFY 3 [_1165=[2| _1693]]% call  1>2 % De drie laatste unificaties zijn hierbij eigenlijk overbodig, omdat we al% bij voorbaat weten dat ze niet zullen slagen. In de versie met de cut zijn% deze niet meer aanwezig:%call  merge2([1, 3, 5], [2, 3], _1165)%UNIFY 1 [_1165=[1| _1691]]% call  1<2% call  !% call  merge2([3, 5], [2, 3], _1691)% UNIFY 1 [_1691=[3| _1951]]%  call  3<2% UNIFY 2 [_1691=[3, 2| _1954]]%  call  3=2% UNIFY 3 [_1691=[2| _1953]]%  call  3>2%  call  !%  call  merge2([3, 5], [3], _1953)%  UNIFY 1 [_1953=[3| _2213]]%   call  3<3%  UNIFY 2 [_1953=[3, 3| _2216]]%   call  3=3%   call  !%   call  merge2([5], [], _2216)%   UNIFY 5 [_2216=[5]]   % (d) Met rode cuts.merge3([X|Xs],[Y|Ys],[X|M]) :- X<Y, !, merge3(Xs,[Y|Ys],M).merge3([X|Xs],[Y|Ys],[X,Y|M]) :- X=Y, !, merge3(Xs,Ys,M).merge3([X|Xs],[Y|Ys],[Y|M]) :- !, merge3([X|Xs],Ys,M).merge3([],Ys,Ys) :- !.merge3(Xs,[],Xs) :- !.% (e) Trace van merge([1, 3, 5], [2, 2], Xs)%call  merge3([1, 3, 5], [2, 3], _1164)%UNIFY 1 [_1164=[1| _1426]]% call  1<2% call  !% call  merge3([3, 5], [2, 3], _1426)% UNIFY 1 [_1426=[3| _1686]]%  call  3<2% UNIFY 2 [_1426=[3, 2| _1689]]%  call  3=2% UNIFY 3 [_1426=[2| _1688]]%  call  !%  call  merge3([3, 5], [3], _1688)%  UNIFY 1 [_1688=[3| _1841]]%   call  3<3%  UNIFY 2 [_1688=[3, 3| _1844]]%   call  3=3%   call  !%   call  merge3([5], [], _1844)%   UNIFY 5 [_1844=[5]]%    call  !% Vraag 3% -------% (a) Zonder cuts.minimum1(X,Y,X) :- X=<Y.minimum1(X,Y,Y) :- X>Y.% (b) Met groene cuts.minimum2(X,Y,X) :- X=<Y, !.minimum2(X,Y,Y) :- X>Y.% (c) Met rode cuts.minimum3(X,Y,X) :- X=<Y, !.minimum3(X,Y,Y).% (d) % minimum3(2,5,5)	=>	yesminimum4(X,Y,Z) :- X=<Y, !, Z=X.minimum4(X,Y,Y).% Vraag 4% -------% (a) Zonder cuts.maximum1(X,Y,X) :- X>=Y.maximum1(X,Y,Y) :- X<Y.% (b) Met groene cuts.maximum2(X,Y,X) :- X>=Y, !.maximum2(X,Y,Y) :- X<Y.% (c) Met rode cuts.maximum3(X,Y,Z) :- X>=Y, !, Z=X.maximum3(X,Y,Y).% Vraag 5% -------p(1).p(2) :- !.p(3).% Query p(X)%call  p(_1146)%UNIFY 1 [_1146=1]		=> X=1%UNIFY 2 [_1146=2]		=> X=2% call  !				(deze cut verbiedt andere mogelijkheden voor X)%		  				=> No more solutions.% Query p(X),p(Y)%call  p(_953)%UNIFY 1 [_953=1]%call  p(_954)%UNIFY 1 [_954=1]		=> X=1, Y=1%UNIFY 2 [_954=2]		=> X=1, Y=2% call  !				(deze cut verbiedt andere mogelijkheden voor Y)%UNIFY 2 [_953=2]% call  !				(deze cut verbiedt andere mogelijkheden voor X)%call  p(_954)%UNIFY 1 [_954=1]		=> X=2, Y=1%UNIFY 2 [_954=2]		=> X=2, Y=2% call  !				(deze cut verbiedt andere mogelijkheden voor Y)%						=> No more solutions.% Query p(X),!,p(Y)%call  p(_903)%UNIFY 1 [_903=1]%call  !				(deze cut verbiedt andere mogelijkheden voor X)%call  p(_904)%UNIFY 1 [_904=1]		=> X=1, Y=1%UNIFY 2 [_904=2]		=> X=1, Y=2% call  !				(deze cut verbiedt andere mogelijkheden voor Y)%						=> No more solutions.						% Vraag 6% -------% Deel (a):likes(mary,X) :- snake(X), !, fail.likes(mary,X) :- animal(X).snake(snake).animal(dog).animal(chicken).animal(snake).% Opmerking: fail is een goal die altijd als resultaat false geeft.% Deel (b):mynot(X) :- X, !, fail.mynot(X).% Als X waar is, dan zal de eerste regel afgevuurd worden met als resultaat fail.% Als X vals is, dan mislukt de eerste regel voor de cut, en slaagt de tweede% regel die bijgevolg gewoon true zal antwoorden. % Maar deze not is niet dezelfde als de logische not. Beschouw bijvoorbeeld de% query 	X=animal(car),mynot(X)% Deze resulteert in TRUE met als binding X=animal(car).% Deze "not" betekent dus eigenlijk: "Als het kan afgeleid worden, dan is het% vals, en anders is het waar. Daarom is deze negatie niet de negatie uit de% logica, maar een "negation by failure"> Als je er niet in slaagt aan te tonen% dat animal(car) geldt, dan wordt de negatie ervan als waar beschouwd. Terwijl% je eigenlijk zou moeten zeggen: "ik weet het niet bij gebrek aan informatie".% CLOSED WORLD ASSUMPTION:% In de veronderstelling dat alle relevante informatie in de databank zit,% gedraagt de not zich wel goed. Inderdaad, als een query nu faalt betekent het% dat de juiste informatie niet werd gevonden en dus effectief niet bestaat% (vanwege de gemaakte onderstelling). Deze veronderstelling wordt de closed% world assumption genoemd.% Deel (c):% (1)	((a and b) or c) => p% (2)   ((a and b) or ((not a) and c)) => p% (3)	(c or (a and b)) => p% (1) en (3) zijn logisch equivalent%   => versie (3) met cuts is equivalent met versie (1) zonder cuts%   => de cuts gebruikt in (3) zijn groen% (1) en (2) zijn niet logisch equivalent%   => versie (2) met cuts is essentieel verschillend van versie (1) zonder cuts%   => de cuts gebruikt in (2) zijn rood% Deel (d):ifthenelse(Condition,Then,Else) :- Condition,!,Then.ifthenelse(Condition,Then,Else) :- Else.