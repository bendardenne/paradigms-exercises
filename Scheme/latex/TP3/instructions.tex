\documentclass{../../../tp}


\title{Practical Session 5: \scheme}
\author{}

\begin{document}
	
	\maketitle

\section{Parameter lists}

You may have noticed that some \scheme functions are able to take an arbitrary number of arguments. See for instance: 

\begin{minted}{scheme}

(* 1 2 3 4 5 6 7 8 9 10 1.132)
(+ 9 8 7 4)
(map * '(1 2 3) '(4 5 6) '(7 8 9) '(10 11 12))

\end{minted}

This is a very useful syntactic sugar which can be found in modern languages as well: the star operator in Ruby or Python for instance. The way this is done in \scheme is with the dot operator: this operator builds a list from all the arguments that follow it and passes this list to the function. The \schemecode{apply} function that we have already seen is its counterpart: it takes a list, unpacks it, and applies the function to all arguments of the list. 

\begin{instruction}
	Try to implement a \schemecode{my-plus} function which sums up all its arguments. Use the dot operator: 
	
	\begin{minted}{scheme}
	(define (my-plus . mylist)
		... )
	
	\end{minted}
	
	You may want to re-use the \schemecode{accumulate} function you wrote in the previous session.
\end{instruction}


\section{Scoping}

So far, all the functions that we wrote were relatively small. This is common in functional programming. However, some functions may be larger, and require temporary variables for instance. We need to have a way to declare variables locally, inside functions. This is the purpose of the \schemecode{let} function:

	\begin{minted}{scheme}
	(let ((x 10) (y 5)) (* x y))
	\end{minted}

\begin{instruction}
	
	Try to evaluate the following expressions:
	
	\begin{minted}{scheme}
	(let ((x 10) (y x)) (* x y))
	(let* ((x 10) (y x)) (* x y))
	\end{minted}
	
	Can you understand the difference between these two forms? Can you write an expression equivalent to the second expression, using only \schemecode{(let ((x 10)) ...)} and \schemecode{(let ((y x)) ...)}?  
	
\end{instruction}


\section{Lexical scoping}

When trying to resolve a reference, an interpreter has two different possibilities: use lexical scoping or dynamic scoping. In lexical scoping, the resolution of an identifier depends on its location in the source code, whereas in dynamic scoping its depends on its use at runtime. Perhaps more simply, this means that to resolve a statically scoped binding, the interpreter will look in the current block, and failing to that in the outer block, and then the outer block, etc. In dynamic scoping, the interpreter will look in the scope of the function, then the calling function etc. 

\begin{instruction}
	Consider the following piece of code :
	\begin{minted}{scheme}
	(define x 1)
	(define (f x) (g 2))
	(define (g y) (+ x y))
	(f 5)   
	\end{minted}
	
	Can you try to guess the two possible values of \schemecode{(f 5)} in the case of a statistically and dynamically scoped interpreters? If you run this in the racket R5RS interpreter, can you tell chat kind of scoping \scheme uses?
	
\end{instruction}

When running \schemecode{(f 5)} above, what happens is this: the interpreter must resolve \schemecode{f}. It is defined as \schemecode{(g 2)}. It must now resolve \schemecode{(g 2)}, which is \schemecode{(+ x y)} and \schemecode{y} is obviously 2 but the value of \schemecode{x} is unknown in the direct scope of \schemecode{g}. With dynamic scoping, the interpreter will look for a binding of \schemecode{x} in the function calling \schemecode{g}. In this case, it is \schemecode{f} where \schemecode{x} is equal to 5. But in static scoping, it will not look in the calling function but in the direct outer block of \schemecode{g}, which here is the global scope, where \schemecode{x} has been defined as 1.

It is very important to understand the difference and to know which approach the language uses, especially when doing functional programming: if a function is passed as argument, you should know how the variables are going to be bound if they are not completely local to the function if you want to be able to predict the behaviour of the function.

\begin{instruction}
	
	What about 
	
	\begin{minted}{scheme}
	(let ((a 5)) 
		(let ((fun (lambda (x) (max a x))))
			(let ((a 10) (x 20))
				(fun 1))))
	\end{minted}
	
	What is the effective binding of \schemecode{x} in \schemecode{fun}? 
	
\end{instruction}


\section{Mutability}

Modern functional languages emphasize the immutability of data: once a data structure is created, it can no longer be modified but rather new structures must be created, usually by applying a transformation on your existing structure.

\begin{instruction} 
	Think about \schemecode{map} for instance. In \scheme, what happens to \schemecode{mylist} after evaluating these two expressions?
	
	\begin{minted}{scheme}
	(define (mylist (list 1 2 4 2 57 9 .1 3 12 -75)))
	(map (lambda (x) (/ (sqrt x) x)) mylist)
	\end{minted}

\end{instruction}

The main advantage (among others) of immutable data structures is that they are inherently thread-safe. They avoid many problems and make it easier to understand the code, keep it consistent even when exceptions occur, and make it easy to parallelize. 

But \scheme's data structures are actually mutable. You may have noticed that when you tell racket to use the R5RS standard, it will display lists as a series of \schemecode{mcons} constructs. This is because of the internal implementation of the \scheme standard in racket: the racket language prevents mutable lists by default, and lists built with \schemecode{cons} in the racket language cannot be modified in memory later on. However, it provides special functions to use, when the user specifically wants to have mutability: \schemecode{mcons, mcar, mcdr}. And because pure \scheme (unlike racket) has mutable lists by default, the \scheme \schemecode{cons} actually corresponds to racket's \schemecode{mcons}, which is why there is some confusion.

\begin{instruction}
	We will play around with mutable lists in \scheme (don't forget to use \schemecode{#lang r5rs}).

	\begin{minted}{scheme}
	(define mutable (list 1 2 4 2 57 9 .1 3 12 -75))

	(set-car! mutable 20)
	(set-car! (cdr mutable) 10)
	
	(set-cdr! (cdr mutable) '(just changing my cdr))
	 
	(set-cdr! mutable mutable)
	 \end{minted}

	What is the value of this last expression? What would happen if you called (don't) \schemecode{(apply + mutable)} for instance?
	
	\begin{minted}{scheme}	
	(define immutable '(this list wont change))
	(set-cdr! mutable immutable)
	(set-car! (cdddr mutable) 'can)
	 \end{minted}
	 
	 What is the value of \schemecode{immutable} now? What happened? 	
\end{instruction}

\begin{instruction}
	Write an \schemecode{append! x y} function which appends list \schemecode{y} to \schemecode{x}, changing the actual structure of \schemecode{x} in memory (it is a good \scheme practice to suffix functions which mutate some or all of their inputs with a \schemecode{!}).  
\end{instruction}


\begin{instruction}
	
	Consider the following \schemecode{mystery} function. Can you guess what it does without evaluating it? 
	
	\begin{minted}{scheme}
	(define (mystery x)
	   (define (loop x y)
	      (if (null? x)
	         y
	         (let ((temp (cdr x)))
	            (set-cdr! x y)
	            (loop temp x))))
	   (loop x '()))
	\end{minted}
	
	Assume we have two lists:
	
	\begin{minted}{scheme}
	(define v '(a b c d))
	(define w (mystery v))
	\end{minted}
	
	What does \schemecode{w} look like? What has \schemecode{v} become? Why?
	
\end{instruction}

\end{document}